{
  "language": "Solidity",
  "sources": {
    "src/ChainPlay.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport {Counters} from \"./Counters.sol\";\n\n/**\n * @title Gaming Grant Platform Contract\n * @notice A decentralized platform where gaming companies can create grants,\n *         game developers can post their games, and users can vote and fund games.\n *         After the grant duration ends, funds are distributed using Quadratic Funding rules.\n */\ncontract GamingGrantPlatform {\n    using Counters for Counters.Counter;\n\n    /* Errors */\n    error GrantDurationOver();\n    error InvalidGrant();\n    error VotingNotOpen();\n    error NotEnoughFunds();\n    error GameAlreadySubmitted();\n    error NotGrantCreator();\n\n    /* Type declarations */\n    enum Genre {\n        Action,\n        Adventure,\n        RPG,\n        Strategy,\n        Sports,\n        Puzzle\n    }\n\n    struct Grant {\n        string name;\n        uint256 totalAmount;\n        uint256 startTime;\n        uint256 duration;\n        bool finalized;\n        uint256[] games;\n        uint256 totalVotes;\n        address creator;\n        string grantURI;\n    }\n\n    struct Game {\n        string name;\n        string details;\n        address developer;\n        uint256 voteCount;\n        uint256 funding;\n        string gameURI;\n        string imageURI;\n        string videoURI;\n        Genre genre; // New genre field added here\n        uint256 grantId;\n    }\n\n    /* State variables */\n    Counters.Counter private grantIdCounter;\n    Counters.Counter private gameIdCounter;\n\n    mapping(uint256 => Grant) private grants;\n    mapping(uint256 => Game) private games;\n    mapping(address => mapping(uint256 => bool)) private submittedGames;\n    mapping(uint256 => mapping(address => uint256)) private votes;\n    mapping(uint256 => mapping(address => bool)) private hasVoted;\n\n    /* Events */\n    event GrantCreated(\n        uint256 indexed grantId,\n        string name,\n        uint256 totalAmount,\n        uint256 startTime,\n        uint256 duration,\n        string grantURI\n    );\n    event GameSubmitted(\n        uint256 indexed grantId,\n        uint256 indexed gameId,\n        address indexed developer,\n        string gameURI,\n        string imageURI,\n        string videoURI,\n        Genre genre // Emit genre in the GameSubmitted event\n    );\n    event Voted(uint256 indexed gameId, address indexed voter, uint256 amount);\n    event GrantFinalized(\n        uint256 indexed grantId,\n        uint256 totalVotes,\n        uint256 totalAmountDistributed\n    );\n\n    /* Modifiers */\n    modifier grantActive(uint256 grantId) {\n        require(\n            block.timestamp <=\n                grants[grantId].startTime + grants[grantId].duration,\n            \"Grant has ended\"\n        );\n        _;\n    }\n\n    modifier grantExists(uint256 grantId) {\n        require(grants[grantId].startTime != 0, \"Grant does not exist\");\n        _;\n    }\n\n    modifier onlyGrantCreator(uint256 grantId) {\n        if (msg.sender != grants[grantId].creator) revert NotGrantCreator();\n        _;\n    }\n\n    /* Functions */\n\n    function createGrant(\n        string memory name,\n        uint256 totalAmount,\n        uint256 duration,\n        string memory grantURI\n    ) external payable {\n        require(msg.value == totalAmount, \"Ether sent must equal totalAmount\");\n\n        grantIdCounter.increment();\n        uint256 grantId = grantIdCounter.current();\n\n        grants[grantId] = Grant({\n            name: name,\n            totalAmount: totalAmount,\n            startTime: block.timestamp,\n            duration: duration,\n            finalized: false,\n            games: new uint256[](0),\n            totalVotes: 0,\n            creator: msg.sender,\n            grantURI: grantURI\n        });\n\n        emit GrantCreated(\n            grantId,\n            name,\n            totalAmount,\n            block.timestamp,\n            duration,\n            grantURI\n        );\n    }\n\n    function submitGame(\n        uint256 grantId,\n        string memory gameName,\n        string memory gameDetails,\n        string memory gameURI,\n        string memory imageURI,\n        string memory videoURI,\n        Genre genre // Genre parameter added here\n    ) external grantExists(grantId) grantActive(grantId) {\n        if (submittedGames[msg.sender][grantId]) {\n            revert GameAlreadySubmitted();\n        }\n\n        gameIdCounter.increment();\n        uint256 gameId = gameIdCounter.current();\n\n        games[gameId] = Game({\n            name: gameName,\n            details: gameDetails,\n            developer: msg.sender,\n            voteCount: 0,\n            funding: 0,\n            gameURI: gameURI,\n            imageURI: imageURI,\n            videoURI: videoURI,\n            genre: genre,\n            grantId: grantId\n        });\n\n        grants[grantId].games.push(gameId);\n        submittedGames[msg.sender][grantId] = true;\n\n        emit GameSubmitted(\n            grantId,\n            gameId,\n            msg.sender,\n            gameURI,\n            imageURI,\n            videoURI,\n            genre\n        );\n    }\n\n    /**\n     * @notice Allows users to vote and fund their favorite game under a specific grant.\n     * @param gameId ID of the game.\n     * @param grantId ID of the grant.\n     */\n    function vote(\n        uint256 gameId,\n        uint256 grantId\n    ) external payable grantExists(grantId) grantActive(grantId) {\n        require(msg.value > 0, \"Not enough funds sent\");\n        require(!hasVoted[grantId][msg.sender], \"Already voted\");\n\n        votes[grantId][msg.sender] += msg.value;\n        hasVoted[grantId][msg.sender] = true;\n\n        games[gameId].voteCount++;\n        games[gameId].funding += msg.value;\n        grants[grantId].totalVotes++;\n\n        emit Voted(gameId, msg.sender, msg.value);\n    }\n\n    /**\n     * @notice Finalizes the grant after the duration is over and distributes the grant using Quadratic Funding.\n     * @param grantId ID of the grant to be finalized.\n     */\n    function finalizeGrant(\n        uint256 grantId\n    ) external grantExists(grantId) onlyGrantCreator(grantId) {\n        Grant storage grant = grants[grantId];\n        require(\n            block.timestamp > grant.startTime + grant.duration,\n            \"Grant duration not over\"\n        );\n        require(!grant.finalized, \"Grant already finalized\");\n\n        uint256 totalFunding = grant.totalAmount;\n\n        // Ensure there are votes to avoid division by zero\n        if (grant.totalVotes > 0) {\n            // Quadratic funding logic\n            for (uint256 i = 0; i < grant.games.length; i++) {\n                uint256 gameId = grant.games[i];\n                Game storage game = games[gameId];\n                uint256 sumOfSquareRoots;\n\n                // Calculate sum(sqrt(c_i)) for each game's contributions\n                for (uint256 j = 0; j < grant.totalVotes; j++) {\n                    uint256 contribution = votes[grantId][game.developer];\n                    sumOfSquareRoots += sqrt(contribution);\n                }\n\n                // Calculate the matched amount using the sum of square roots\n                uint256 matchedAmount = (totalFunding * sumOfSquareRoots) /\n                    grant.totalVotes;\n\n                // Update the funding and transfer to the developer\n                game.funding += matchedAmount;\n                payable(game.developer).transfer(game.funding);\n            }\n        }\n\n        grant.finalized = true;\n        emit GrantFinalized(grantId, grant.totalVotes, totalFunding);\n    }\n\n    /**\n     * @dev Computes the integer square root of a number.\n     */\n    function sqrt(uint256 x) private pure returns (uint256) {\n        uint256 z = (x + 1) / 2;\n        uint256 y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        return y;\n    }\n\n    /* Getter Functions */\n    function getGrant(uint256 grantId) external view returns (Grant memory) {\n        return grants[grantId];\n    }\n\n    function getGame(uint256 gameId) external view returns (Game memory) {\n        return games[gameId];\n    }\n\n    function getTotalVotes(uint256 grantId) external view returns (uint256) {\n        return grants[grantId].totalVotes;\n    }\n\n    function getVoteCount(uint256 gameId) external view returns (uint256) {\n        return games[gameId].voteCount;\n    }\n\n    function getAllGamesOfGrant(\n        uint256 grantId\n    ) external view returns (Game[] memory) {\n        uint256[] memory gameIds = grants[grantId].games;\n        Game[] memory gamesInGrant = new Game[](gameIds.length);\n\n        for (uint256 i = 0; i < gameIds.length; i++) {\n            gamesInGrant[i] = games[gameIds[i]];\n        }\n\n        return gamesInGrant;\n    }\n\n    function getAllGrants() external view returns (Grant[] memory) {\n        Grant[] memory allGrants = new Grant[](grantIdCounter.current());\n        for (uint256 i = 1; i <= grantIdCounter.current(); i++) {\n            allGrants[i - 1] = grants[i];\n        }\n        return allGrants;\n    }\n\n    function getAllGames() external view returns (Game[] memory) {\n        Game[] memory allGames = new Game[](gameIdCounter.current());\n        for (uint256 i = 1; i <= gameIdCounter.current(); i++) {\n            allGames[i - 1] = games[i];\n        }\n        return allGames;\n    }\n\n    /**\n     * @notice Fetches all games on the platform by genre.\n     * @param genre Genre to filter games by.\n     * @return gamesByGenre Array of games that match the specified genre.\n     */\n    function getAllGamesByGenre(\n        Genre genre\n    ) external view returns (Game[] memory) {\n        uint256 gameCount = gameIdCounter.current();\n        uint256 matchingGameCount;\n\n        // First loop to count matching games\n        for (uint256 i = 1; i <= gameCount; i++) {\n            if (games[i].genre == genre) {\n                matchingGameCount++;\n            }\n        }\n\n        // Create a temporary array to hold the matching games\n        Game[] memory gamesByGenre = new Game[](matchingGameCount);\n        uint256 index;\n\n        // Second loop to populate the array with matching games\n        for (uint256 i = 1; i <= gameCount; i++) {\n            if (games[i].genre == genre) {\n                gamesByGenre[index] = games[i];\n                index++;\n            }\n        }\n\n        return gamesByGenre;\n    }\n}\n"
    },
    "src/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/**\n * @title Counters\n * @dev Provides counters that can only be incremented, decremented, or reset. Useful for tracking elements count,\n * issuing IDs, or counting items with minimal overhead.\n */\nlibrary Counters {\n    struct Counter {\n        uint256 _value; // Default to 0\n    }\n\n    /**\n     * @dev Returns the current value of the counter.\n     * @param counter Counter to get the current value of.\n     * @return uint256 The current value of the counter.\n     */\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    /**\n     * @dev Increment the counter value by 1.\n     * @param counter Counter to increment.\n     */\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    /**\n     * @dev Decrement the counter value by 1. Reverts if the counter is 0.\n     * @param counter Counter to decrement.\n     */\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    /**\n     * @dev Resets the counter value to 0.\n     * @param counter Counter to reset.\n     */\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/=lib/openzeppelin-contracts/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/"
    ],
    "optimizer": { "enabled": true, "runs": 200 },
    "metadata": {
      "useLiteralContent": false,
      "bytecodeHash": "ipfs",
      "appendCBOR": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "evmVersion": "paris",
    "viaIR": false,
    "libraries": {}
  }
}
